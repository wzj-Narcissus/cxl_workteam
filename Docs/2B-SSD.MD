### 一些英文专业名词的解释

| 专有名词                       |           中文示意            | 举例说明                                           |
| ------------------------------- | ------------------------------ | ------------------------------------------------------- |
| **NVRAM（ Non-Volatile Random-Access Memory）**         | 非易失性随机访问内存               | 传统内存的随机访问速度和传统存储的持久性。    |
| **NVMe（Non-Volatile Memory Express）** | 非易失性内存表达式 | 通信协议（接口标准）专门为SSD等非易失性存储设备设计，用于通过PCIe总线与计算机系统连接 |
| **SSD（Solid-State Drive）**         | 固态硬盘 | 一种使用纯电子电路构成的存储设备       |
|**HDD（Hard Disk Drive）**| 硬盘驱动器 | 一种传统的存储设备，使用机械硬盘盘和磁头来读写数据。 |
| **2B-SSD（Two-Block SSD）** | 双块SSD | 一种结合了NVRAM和传统SSD的存储设备，通过在传统SSD中融入NVRAM特性和双访问模式，来解决传统SSD在特定场景下的性能瓶颈。 |
|**DIMM（Dual In-line Memory Module）**| 双列直插内存模块 |  “内存条”，一种用于扩展计算机内存的模块，通常包含多个内存芯片，每个芯片都有自己的地址和数据总线。 |
|**PM（persistent memory）**| 持久化内存 | 一种特殊的内存类型，数据写入后即使断电也不会丢失。一种理想的，新型的NVRAM。 |

---

### SSD的主要组成部分

一个典型的SSD主要由三大部分构成：

#### 1. NAND Flash Memory（闪存颗粒）— **仓库**

这是真正存储数据的物理介质，是SSD的“仓库”。

- **物理结构**：
    - **Page（页）**：**最小的读写单位**，通常是 4KB, 8KB, 16KB。就像仓库里的一排货架，你要取/放一件东西，也必须操作一整排。
    - **Block（块）**：**最小的擦除单位**，由几十到几百个Page组成。就像一个由很多排货架组成的房间。**关键问题**：SSD不能直接覆盖写入一个Page，必须先擦除整个Block，然后再写入。这导致了“写入放大”问题。
    - **Plane > Die > Package**：多个Block组成Plane，多个Plane组成Die（晶圆），多个Die封装成一个Package（闪存颗粒）。这些层级允许并行操作，提升速度。

**核心特性**：**读写不对称**：读快，写慢。**写前擦除**：无法覆盖写，必须先擦除。**寿命有限**：每个Block都有有限的擦写次数。


#### 2. Controller（主控芯片）— **大脑与总管**

是SSD的“大脑”和“总管”，其内部集成了一系列关键模块。

- **CPU核心**：通常是一个或多个ARM RISC内核，负责执行固件指令，协调所有操作。
- **闪存转换层（FTL）**：它解决了NAND闪存的硬件缺陷，让SSD在操作系统看来就像一个可以随意覆盖写的普通硬盘。
    - **地址转换**：将操作系统看到的**逻辑区块地址（LBA）**，映射到闪存上真实的**物理地址**。
    - **磨损均衡**：确保数据均匀地写入所有Block，避免部分Block被过早写坏，从而延长整体寿命。
    - **垃圾回收**：当一个Block中有无效数据时，GC机制会将其中有效的Page搬到一个新Block，然后擦除旧Block，以供后续使用。这是造成SSD性能波动和写入放大的主要原因。
    - **坏块管理**：标记和隔离无法使用或出错的Block。
- **ECC引擎**：**错误纠正码**。随着NAND工艺进步，数据出错的概率增高。ECC引擎通过复杂的算法（如LDPC）来检测和纠正数据错误，是保证数据可靠性的关键。
- **主机接口控制器**：实现与计算机通信的协议，如NVMe, SATA, AHCI等。
- **DRAM控制器**：管理外部DRAM缓存（如果有的话）。

#### 3. DRAM（缓存）— **地图与工作台**

- **作用**：
    1.  **缓存FTL映射表**：这是最主要的作用。映射表记录了LBA到物理地址的对应关系，频繁访问。将其放在高速的DRAM中可以极大提升读写速度。
    2.  **数据缓存**：临时存放要写入或读取的数据。
- **注意**：并非所有SSD都有外置DRAM缓存。**无DRAM缓存**的SSD通常使用主机内存或闪存的一部分来存放映射表，成本更低，但性能（特别是随机读写和持续写入后的性能）通常会受影响。
- **在2B-SSD中**：论文创新地利用了这部分**SSD内部DRAM**，将其通过电容备份变成了一个持久化的字节寻址缓冲区。

### 4. 其他组件
- **PCB**：印刷电路板，所有组件都安装在这上面。
- **外部电容**：用于**断电保护**。在意外断电时，电容储存的电量可以为SSD提供足够的能量，让它完成正在进行的写入操作，并将缓存中的数据安全地写入闪存，防止数据损坏。**2B-SSD的电容还被用来保护其BA-buffer中的数据**。
- **固件**：运行在主控CPU上的操作系统和软件。固件的质量直接决定了SSD的性能、稳定性和兼容性。2B-SSD的复杂功能（如BA-buffer管理）就是通过固件实现的。

---

| 传统 SSD                                              | 2B-SSD                                                                                           |
| :---------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------- |
| 只能通过**块**来访问（例如，每次读写4KB的数据块）。   | **同时支持“块”和“字节”两种访问方式**。                                                                           |
| 内部的DRAM仅用作缓存或映射表，对主机完全不可见。      | 将一部分内部DRAM通过电容备份变成**NVRAM**，并**直接映射到主机的内存地址空间**，让CPU能像访问内存一样直接访问它。 |
| 数据必须通过复杂的I/O软件栈（操作系统、驱动程序等）。 | 对于字节访问，**绕过了厚重的I/O软件栈**，实现了接近内存的极低延迟。                                              |
| 小文件写入性能差，因为必须凑满一个块才能高效写入。    | **完美解决小文件写入问题**，应用程序可以只写入几个字节，并立即持久化。                                           |


---

## 🧩 研究背景与动机

- **传统存储瓶颈**：现代数据库和存储系统依赖**非易失性内存（NVRAM）** 作为写入缓冲区，但传统电池备份的DRAM方案成本高、容量小，且占用DIMM插槽。
- **两种技术趋势**：
  1. **HDD → SSD 的快速迁移**，尤其是高性能场景；
  2. **持久内存（Persistent Memory, PM）** 的兴起，但其容量有限、价格昂贵，且无法完全替代块存储。
- **现有架构问题**：
  - PM 无法被块I/O访问，必须通过整个I/O栈；
  - 缺乏同时支持**字节寻址**和**块寻址**的统一存储设备。

---

## 💡 2B-SSD 核心思想

2B-SSD 是一种**同时支持字节寻址和块寻址的NVMe SSD**，其核心创新包括：

- **双路径访问同一文件**：
  - **字节寻址路径**：实现一个地址转换硬件，该硬件将对内存映射I/O（MMIO）的字节级访问请求重定向到SSD内部的DRAM（即BA-buffer）；
  - **块寻址路径**：传统的NVMe块I/O路径。
- **内部数据通路**：引入内部数据通路，该通路位于SSD内部DRAM与NAND闪存之间，用于直接数据传输。
- **持久性保证**：通过电容备份和固件机制，确保DRAM中的数据在断电时不丢失。


## 🛠 2B-SSD 架构与关键技术

### 1. **四大核心组件**
- **BAR Manager（基址寄存器管理器）**：除标准的 BAR0（用于 NVMe 控制寄存器）。新增一个BAR（BAR1），将CPU内存访问重定向到SSD内部DRAM。BAR1 暴露给主机一个字节可寻址的内存窗口，CPU 可以通过 MMIO 直接访问这个窗口，并通过ATU动态映射到SSD内部的DRAM（BA-buffer）。
- **BA-Buffer Manager**：管理DRAM与NAND之间的映射与数据传输。维护一个映射表，记录文件在NAND中的逻辑块地址（LBA）与BA-buffer中的物理地址（PA）的映射关系。
- **Read DMA Engine**：加速大块数据的读取操作。
- **Recovery Manager**：处理断电恢复，确保数据持久性。

### 2. **持久性保证机制**
- 使用 `clflush` + `mfence` 刷新CPU写合并缓冲区；
- 使用“写验证读”确保PCIe根复合体中的写操作完成。

### 3. **软件API**
- `BA_PIN()`：将NAND数据映射到BA-buffer；
- `BA_FLUSH()`：将BA-buffer数据刷回NAND；
- `BA_SYNC()`：确保BA-buffer中的数据持久化；
- `BA_READ_DMA()`：使用DMA加速读取。




## 🧪 案例研究：数据库日志（WAL）

- **BA-WAL**：将WAL日志直接写入2B-SSD的BA-buffer，避免主机内存缓冲和频繁的 `fsync()`；
- **三种提交模式对比**：
  - **同步提交**：安全但慢；
  - **异步提交**：快但有数据丢失风险；
  - **BA提交**：兼具高性能与持久性。

---



## 🌍 背景

- 为了从这些设备中获得最佳性能，应用程序，可能会绕过操作系统内核，通过用户级驱动程序直接访问存储设备。
- 像日志和提交这样的小而频繁的写入长期以来被认为是使用小型PM进行优化的完美目标。在今天，PM通常是使用电池支持的DRAM（或NVRAM）实现的。

- 提倡如图（d）所示的混合存储架构。在能力方面，混合存储架构与异构存储架构相似。混合存储架构中字节寻址的PM容量由SSD提供。使用现代I/O互连（如PCIe）。

- 为实现如前所述的混合存储架构，底层的I/O互连必须能够为进出I/O设备的内存访问提供服务。2BSSD架构建立在PCIe之上。还可采用CCIX/CXL等缓存一致性协议，以实现字节寻址的PM与块寻址的SSD之间的内存共享。

###  对比

| 技术     | 解释                                | 功能                                                                                                                         |
| :------- | :---------------------------------- | :--------------------------------------------------------------------------------------------------------------------------- |
| **PCIe** | **成熟的、广泛应用的 I/O 互联标准** | 连接 CPU 与各种I/O 设备，实现**数据移动**。它本质上是**主从式**架构，CPU 是主机，设备是从属。                                |
| **CCIX** | **基于 PCIe 的缓存一致性协议**      | 主要目标是实现 CPU 与**其他智能设备**（如加速器、FPGA）之间的**内存共享**，让它们能够像多核 CPU 一样高效地访问同一内存空间。 |
| **CXL**  | **CCIX 的进化版和替代者**           | **更先进、更统一的“共享”协议**，已成为未来发展的主流方向。                                                                   |


如何在典型平台上识别PCIe设备。
这个过程可以看作是 PCIe 设备从“沉睡”到“就绪”的唤醒过程，涉及硬件和软件的紧密配合。

###  PCIe 设备初始化流程总览

整个初始化过程可以清晰地分为以下几个关键阶段：

1.  **硬件复位**
2.  **PCI 枚举**
3.  **资源配置**
4.  **设备驱动加载**


####  第一阶段：硬件复位

当系统上电或发生重置时，PCIe 设备首先进入硬件复位状态。

*   **触发方式**：
    *   **冷启动**：系统电源接通。
    *   **热启动**：操作系统发起重启。
    *   **Fundamental Reset**：通过 PCIe 的 `PERST#` 信号线触发的硬复位。
*   **设备状态**：
    *   设备进入一个已知的、安全的初始状态。
    *   大部分内部逻辑被重置。
    *   **配置空间** 被设置为默认值（少数由 BIOS 设定的固定字段除外）。


####  第二阶段：PCI 枚举

整个初始化过程的核心，主要由 **系统 BIOS/UEFI** 在操作系统启动前执行。“发现”系统中所有存在的 PCI/PCIe 设备，并为它们分配唯一的地址。

##### 1. **总线扫描**
- BIOS 从 **总线 0** 开始，逐个扫描每个可能的 **设备号** 和 **功能号**。
- 尝试读取每个可能位置上的 **供应商 ID**。
- 如果返回的 Vendor ID 是 `0xFFFF`，则表示该位置没有设备。
- 如果返回一个有效的 Vendor ID，则表示发现了一个设备。

##### 2. **递归探索**
- 当发现一个 **桥设备** 时，系统会：
    - 分配一个新的**总线编号**给该桥下游的总线。
    - **递归地**扫描这个新总线上的设备。
- 这个过程持续进行，直到整个 PCIe 拓扑结构（包括根复合体、交换机和端点设备）都被完整映射。

##### 3. **构建设备树**
- 通过枚举，系统在内存中构建出一幅完整的 **PCIe 设备树**，记录了：
    - 每个设备的 **(总线号，设备号，功能号)**
    - 设备类型（是端点还是桥）
    - 供应商和设备 ID


####  第三阶段：资源配置

在发现所有设备后，系统需要为它们分配合适的运行资源，主要是**内存和 I/O 空间**。

##### 1. **BAR 的配置(关键步骤)**

*   **BAR 的作用**：每个 PCIe 设备通过 **基址寄存器** 向系统“申领”它需要多少地址空间，以及是内存空间还是 I/O 空间。
*   **配置流程**：
    1.  **系统查询**：BIOS/OS 向设备的 BAR 写入全 `1` (`0xFFFF...`)。
    2.  **设备回应**：设备会返回一个值，其中**低位为 0 的比特位**表示它需要的地址空间大小。
        *   例如，如果一个 BAR 返回 `0xFFFF0000`，意味着它需要 64KB 的空间（因为低 16 位是 0）。
    3.  **地址分配**：系统根据所有设备的请求，在系统的物理地址空间中为每个 BAR 分配一个**唯一的、非重叠的基地址**。
    4.  **地址写入**：系统将这个分配好的基地址写回设备的 BAR。

**完成此步骤后**：
- CPU 或 DMA 操作访问这个 **BAR 地址范围** 时，请求会被 **PCIe 根复合体** 拦截，并通过 PCIe 链路路由到对应的设备。
- 这正是 **2B-SSD 实现字节寻址的基石**：系统将 SSD 的 BAR1 分配了一个地址窗口，CPU 对该窗口的 MMIO 访问被直接路由到 SSD 内部的 DRAM。

##### 2. **中断配置**
- 系统为设备配置中断线或 MSI/MSI-X 中断机制，使设备能够向 CPU 发送服务请求。

####  第四阶段：设备驱动加载

这是操作系统接管后的阶段。

1.  **操作系统接管**：操作系统启动后，会接收或重新构建 PCIe 设备树。
2.  **驱动匹配**：操作系统根据设备的 ** Vendor ID 和 Device ID**，在驱动库中寻找匹配的设备驱动程序。
3.  **驱动加载与初始化**：
    - 加载对应的驱动程序到内核。
    - 驱动程序会：
        - 进一步初始化设备特定的功能。
        - 可能重新分配或映射资源。
        - 向操作系统注册自己，并准备好处理请求。
4.  **设备就绪**：此时，PCIe 设备完全初始化完毕，应用程序可以通过操作系统调用使用该设备。


这正是 2B-SSD 能够实现其架构的**第一步**：
1.  系统通过枚举发现 2B-SSD 这个 NVMe 设备。
2.  在资源配置阶段，2B-SSD 通过其 **BAR1** 申请并获得了**一段字节可寻址的 MMIO 空间**。
3.  操作系统和应用程序随后可以通过 `mmap()` 将这个 MMIO 空间映射到用户空间，从而实现对 SSD 内部 DRAM 的**直接内存访问**，绕过了传统的块 I/O 栈。

这个过程确保了即插即用，并为像 2B-SSD 这样的创新设备提供了实现高性能特性的底层硬件支持。



## 设计与实现

###  2B-SSD 架构

- 在NAND闪存固态硬盘中，由于底层存储介质不允许对存储的数据进行字节级读写访问，因此不能简单将介质暴露到内存地址空间。为了克服这一限制，采用内部DRAM作为NAND闪存介质中的数据缓存层。