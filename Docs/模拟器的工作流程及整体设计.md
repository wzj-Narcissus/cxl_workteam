# 我们模拟器的工作流程

(我们这里只针对CXL语义，暂不考虑NVMe语义)

1. 向内存中**划出一片空间**比如4G，作为我们模拟器的空间；
2. 从**镜像文件中恢复**到我们划分的内存；
3. 向系统**注册一个字符类型设备**；
4. 当应用缺页会page fault，我们负责实现此时被调用的函数，该函数负责**建立一个虚拟页到应用请求的内容的实际页的映射并写到页表**。同时注入一定时延；
5. 后续如果不缺页，则系统会直接正常读取，我们无法干预；
6. 如果有写操作，再另行处理，这里先不讨论。

# 我们要做的东西

我们要做的是一个**“可插拔式”**的Linux内核模块（一个`.ko`文件）。它不需要修改Linux源码，也不需要重新编译内核。

###　模块整体结构示意

```css
┌──────────────────────────────┐
│ 内核模块：cxl_ssd_sim.ko │
│──────────────────────────────│
│ 模块初始化 (init_module)     │
│   ├─ 分配内存区域（模拟SSD） │
│   ├─ 加载镜像文件            │
│   ├─ 注册字符设备 /dev/ssdmem0│
│   └─ 输出 dmesg 初始化信息   │
│                              │
│ 模块功能接口                 │
│   ├─ ioctl(): 用户态命令交互 │
│   ├─ mmap(): 用户映射接口    │
│   └─ fault(): 缺页处理函数   │
│                              │
│ 模块卸载 (cleanup_module)    │
│   └─ 释放资源、注销设备      │
└──────────────────────────────┘
```

------

## 模拟器架构

```
[ 用户空间 ]
   benchmark.c     # 测试用例，mmap("/dev/ssdmem0")
        │
        ▼
[ 内核空间模块 ]
   cxl_ssd_sim.ko   # 驱动模块
       ├─ ssdmem_init()：注册字符设备
       ├─ ssdmem_mmap()：建立vm_area_struct
       ├─ ssdmem_fault()：缺页时建立映射 + 模拟时延
       └─ ssdmem_exit()：释放资源
       ...
        │
        ▼
[ 内核 mm 子系统 ]
    fault() 回调补页表，完成CXL访问模拟
```


## 模块结构

```
cxl-ssd-sim.c
 ├── init_module()
 │    ├─ 申请内存 (vmalloc_user)
 │    ├─ 从镜像文件读入
 │    ├─ 注册字符设备 /dev/ssdmem0
 │
 ├── file_operations
 │    └─ .mmap -> ssdmem_mmap()
 │            ├─ 设置 vm_ops = &ssdmem_vm_ops
 │            └─ vm_ops->fault = ssdmem_fault()
 │
 ├── ssdmem_fault()
 │    ├─ 定位页号
 │    ├─ 从镜像拷贝数据
 │    ├─ usleep_range() 模拟访问延迟
 │    └─ 返回页对象
 │
 └── exit_module()
      ├─ 释放内存
      └─ 注销设备
```

