# 不同访问方式比较

**mmap接口**是Linux/Unix系统提供的一个将一个文件的一部分或全部**“映射”**到进程的虚拟内存地址空间的接口，之后，可以像访问内存一样去读写这个文件。（**注意**：mmap本质是**建立映射关系**，即负责给应用进程一段连续的虚拟地址，并告诉 CPU “这个地址怎么翻译到物理页”，而**不一定需要把东西复制到内存中，比如我们用mmap来访问真正的CXL-SSD时就不需要复制到内存中，”CXL-SSD本身就像内存一样“**）

我们可以把访问方式看作三种：

- A.传统的NVMe-SSD访问文件方式（非mmap）
- B.基于mmap和内存模拟出的CXL-SSD访问文件方式
- C.真正的的CXL-SSD访问文件方式

**写在前面：我们这个项目的主要任务就是完成B，一个基于mmap和内存模拟出的CXL-SSD，欲模拟对象是C，后面的性能分析等主要是和A作比较。**

## A.传统 NVMe-SSD 的 read/write 访问流程（非 mmap）

这就是我们日常在用的访问方式：

**场景设计**：

1. 应用用标准 API：`fd = open("file", O_RDONLY); read(fd, buf, size);`
2. 文件挂载在NVMe盘
3. 未使用DAX；页缓存生效。

### 读流程

#### 1) 用户态 → 内核态

1. 应用调用 `read()` → 进入内核（系统调用）。
2. VFS（虚拟文件系统）根据 `fd` 找到具体文件系统的 `file_operations->read_iter`。（简单说：“VFS 会根据文件描述符找到对应的文件对象（`struct file`），然后调用该文件所属的文件系统定义的 `read_iter()` 函数去执行实际的读取操作。”）

> VFS（Virtual File System）= 虚拟文件系统层。是Linux的一层“中间层”，负责把所有文件操作（read/write/open 等）转换成对**具体文件系统**（ext4、xfs、tmpfs、procfs …）的调用。

#### 2) 文件系统层 & 页缓存（Page Cache）

1. 文件系统把**文件偏移**映射成**页缓存页**（4KB 通常）。
2. **若页缓存命中**：直接把页缓存的数据拷贝到用户缓冲区 `buf`（可能用 `copy_to_user` 或零拷贝变体），**这次 read 就结束**。
3. **若不命中**（常见在首次读取或冷数据）：
   - 文件系统发起页缓存缺页填充：为目标文件页创建 `struct page`，并向**块层**发起读请求把这**整页（或多页）**从磁盘读入。

####  3) 块层（Block Layer）& BIO

1. 文件系统构造一个或多个 **BIO**（块 I/O 结构，描述 LBA、长度、目标内存页），递交给通用块层（blk-mq）。
2. 块层可能做：
   - 合并/重排（合并相邻 BIO 形成更大 I/O）；
   - 选择 I/O 队列（多队列 blk-mq：按 CPU/NUMA 选择硬件队列）。

#### 4) NVMe 驱动 & 提交队列（SQ）

1. NVMe 驱动把 BIO 转成 NVMe 命令（如 **READ**），填入**提交队列 SQ**（Submission Queue）条目：
   - 设置**起始 LBA**、**扇区数**；
   - 指向主机内存中数据缓冲区（页缓存页）的**物理地址列表**（PRP/SGL）。
2. **Doorbell**：驱动写入队列门铃寄存器，通知控制器“有新命令”。

#### 5) 设备侧 DMA & 完成队列（CQ）

1. NVMe 控制器从 SQ 取命令，通过 **PCIe DMA** 把数据从设备读到**主机内存**（页缓存页）。
2. 完成后，控制器在 **完成队列 CQ** 写入完成条目（CQE），并通过 **MSI-X 中断**或**轮询**通知主机。

#### 6) 中断处理 & 完成路径

1. 驱动的中断处理程序读取 CQ，标记该 BIO 完成，唤醒上层等待者。
2. 页缓存页标记为“已填充、可用”，VFS 把数据拷贝/映射到用户缓冲区，`read()` 返回。

> **读流程要点**：首次读某个文件页 → **块 I/O 把整页搬进页缓存**；命中后就直接从页缓存返回。
> **I/O 粒度**：通常按**页（4KB）或多页**；不是字节/缓存行。

### 流程简图

```perl
read() syscall
  ↓
VFS / 文件系统
  ↓（查页缓存 miss）
页缓存分配页 → 发 BIO
  ↓
blk-mq（多队列、合并/调度）
  ↓
NVMe 驱动 → SQ 填命令 + PRP/SGL → doorbell
  ↓
NVMe 控制器 DMA 读 → 主机页缓存页
  ↓
控制器写 CQE → 中断/轮询
  ↓
驱动完成 → VFS 把数据给用户 → read() 返回
```

###  C.真正的 CXL.mem（“内存语义”）设备的工作流程

写在前面：CXL-SSD对操作系统来说，就是一块**可寻址的设备内存（device memory）**。本身需要应用程序使用mmap来访问。

### 读流程

#### 1)建立映射：VA → 设备物理页（PFN），不是“读一页到页缓存”

- 当应用使用mmap接口来将文件映射到其内存